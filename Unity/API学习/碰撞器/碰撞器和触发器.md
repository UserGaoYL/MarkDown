### 一、碰撞器


#### 一、需要条件

1. 碰撞的双方必须都要有碰撞器组件(```Collider```)
2. 碰撞的双方中一定至少要有一个```RigidBody```存在
3. 碰撞双方若只有一个刚体，那么这个刚体一定要处于运动状态下才会有碰撞事件发生

#### 二、用法

1. 进入碰撞器执行的代码
```C#
void OnCollisionEnter(Collision col)
{

}
```
2. 持续碰撞器执行的代码
```C#
void OnCollisionStay(Collision col)
{

}
```
3. 离开碰撞器执行的代码
```C#
void OnCollisionExit(Collision col)
{

}
```


### 二、触发器

#### 一、发生条件
1. 必须都要有碰撞器组件(```Collider```)
2. 必须有一个物体带刚体组件(```RigidBody```)，并且处于运动状态(包括主动运动撞击别人和在运动中被被人撞击)
3. 两个碰撞器中至少有一个开启了```IsTrigger```

**TIPS**
```
1. 产生触发事件的两个物体会相互穿越，准确的说是因为开启IsTrigger那个物体会被物理引擎锁忽略掉，所以会产生两个物体穿越的情况
2. 两个对象要么都收到碰撞事件，要么都收到触发事件，不会出现一个收到触发事件，一个收到碰撞事件的情况
```

#### 二、用法

1. 进入触发器执行的代码
```C#
void OnTriggerEnter(Collider col)
{

}
```
2. 持续在触发器执行的代码
```C#
void OnTriggerStay(Collider col)
{

}
```
3. 离开触发器执行的代码
```C#
void OnTriggerExit(Collider col)
{

}
```
4. 额外用法

在控制一个物体A去撞另一个物体B时，不要直接去修改物体A的Tranform的position属性，  
因为你会发现如果即使两者发生了碰撞也还是会穿越的，原因就在于我们是直接设置的坐标，  
如果物体A有刚体组件的话，应该用AddForce，给物体添加一个力，然后让物理引擎去让物体动，  
此时如果发生了碰撞的话，就不会穿越了

### 三、两者关系

1. 当IsTrigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数
2. 当IsTrigger=true时，碰撞器被物理引擎忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数
3. 碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性
4. 如果既要检测到物体的接触又不想让碰撞器检测影响物体移动，或者要检测一个物件是否经过空间中的某个区域，这时就可以用到触发器